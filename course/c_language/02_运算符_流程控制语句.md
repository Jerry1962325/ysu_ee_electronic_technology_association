## 运算符

运算符可以分为算数运算符、关系运算符、逻辑运算符、位运算符、赋值运算符和其他运算符

参与运算的值，我们称其为操作数

在描述运算符时，我们会称其为n元运算符，n指的是操作数的个数，例如：

减法运算符是二元运算符，表达式可以写作`a-b`，可见有两个操作数参与运算

负号运算符是一元运算符，表达式可以写作`-a`，可见有一个操作数参与运算

虽然都使用负号，但是一个是一元运算符，一个是二元运算符，因为操作数个数不同

### 运算符的优先级和结合性

我们小学就学过，先乘除后加减，在编程中，我们说乘法和除法的优先级比加法和减法高

在优先级相同的情况下，我们从左到右计算，我们称该运算左结合

### 算数运算符

| 运算符 | 描述                                                           |
| ------ | -------------------------------------------------------------- |
| +      | 加法                                                           |
| -      | 当只有一个值参与运算时，取这个值的相反数；有两个值时，计算减法 |
| *      | 乘法                                                           |
| /      | 除法                                                           |
| %      | 模运算，即两数相除的余数 (操作数必须是整型)                    |
| ++     | 自增运算符，操作数必须是变量，使变量加一                       |
| --     | 自减运算符，操作数必须是变量，使变量减一                       |

补充解释(仅作了解，初学请跳过)：

除法的特殊情况是除数为浮点数0

```
1.0 / 0.0 结果为inf(无穷大)
-1.0 / 0.0 结果为-inf(负无穷)
-1.0 / -0.0 结果为inf(无穷大)
是的，浮点数正零和负零是不同的
```

当负数参与模运算时，运算规则会比较复杂，所以不建议你使用负数参与模运算

一个使用模运算的典型例子是角度限制，将角度转换为在0~360度内的相同角度

```C
int theta = 114514;
theta = theta % 360;
// 这时theta为34

theta = -90
theta = theta % 360;
// 这时theta为-90度，不在我们希望的范围里

// 如果知道theta的输入值的范围，代码可以写成
theta = (theta + 360 * 100) % 360;
// 这时theta为270
// 如果theta < -360 * 100，就会产生非期望的结果
```

自增操作符和自减运算符可以参与复合运算，例如：

```C

int a = 0;
a++; // 等同于a = a + 1
// 这时a为1

++a; // 等同于a++ 不建议使用
// 这时a为2

a = a++; // a++先保留a的值2，再将a自增，最后将2作为结果。因此最后a依然是2

a = ++a; // ++a先将a自增为3，再将3作为++a的结果。因此最后a为3

a = 3 * ++a + a++ - --a; // 不要写这样的代码，不要浪费时间理解这行代码
```

在以上代码中你是否感到自增自减运算符参与运算时会让本来简单的运算变得异常复杂

因此结论是仅像`a++;`或`a--;`这样使用自增自减运算符，不要让它们参与运算

**尝试理解自增自减运算符参与复合计算的代码会变得不幸!!!**

### 关系运算符

| 运算符 | 描述             |
| ------ | ---------------- |
| ==     | 判断相等         |
| <      | 判断是否小于     |
| <=     | 判断是否小于等于 |
| >      | 判断是否大于     |
| >=     | 判断是否大于等于 |
| !=     | 判断是否不等于   |

一个常见错误是混淆`a=b`与`a==b`

关系运算符的结果一定是bool类型

如果a与b相等，`a==b`为true，否则为false

而`a=b`的结果为b

另一个常见错误是判断浮点数是否相等

例如`0.1 + 0.2 == 0.3`的结果竟然是false

因为浮点数是有表示精度的，因此在工程代码中判断浮点数是否相等会使用以下方法：

```C
#include <stdio.h>
#include <math.h> // 使用了math.h中的fabs函数
// fabs是取浮点数绝对值的函数
#define EPSILON 0.000001
// 宏定义语法，将EPSILON定义为常量0.000001

int main()
{
    printf("%d\n", fabs((0.1 + 0.2) - 0.3) <= EPSILON);
    // 判断0.1 + 0.2是否与0.3相等
    return 0;
}
```

只要两个浮点数的距离在容许误差半径(EPSILON)之内就认为两浮点数相等

### 逻辑运算符

| 运算符 | 描述   |
| ------ | ------ |
| &&     | 与运算 |
| \|\|   | 或运算 |
| !      | 非运算 |

为了描述逻辑运算，我们常使用真值表

真值表列举出了所有输入布尔值组合所对应的输出布尔值

与运算有两个布尔型操作数，分别记为A、B，一个布尔输出

可列出与运算真值表如下：

| A   | B   | A && B |
| --- | --- | ------ |
| F   | F   | F      |
| F   | T   | F      |
| T   | F   | F      |
| T   | T   | T      |

例如第一行表示当输入A，B均为F时，输出C为F

或运算真值表如下：

| A   | B   | A \|\| B |
| --- | --- | -------- |
| F   | F   | F        |
| F   | T   | T        |
| T   | F   | T        |
| T   | T   | T        |

非运算只有一个输入，记为A

非运算真值表：

| A   | !A  |
| --- | --- |
| F   | T   |
| T   | F   |

注意逻辑运算符的优先级：

或运算 > 与运算 > 或运算

补充解释(初学者请跳过)：

`或运算`和`与运算`为短路运算符，这指的是如果左操作数能确定逻辑表达式的值，就不会计算右操作数

例如如果左操作数为真，则`或运算`表达式必定为真，就不会计算右操作数

如果左操作数为假，则`与运算`表达式必定为假，也不会计算右操作数

例如：

```C
#include <stdio.h>
#include <stdbool.h>

int main()
{
    printf("%d\n", true || (0 / 0));
    // 输出1，因为左操作数为true，所以不计算0 / 0，直接得到true
    printf("%d\n", true && (0 / 0));
    // 报错，因为左操作数为true，不能确定 与运算 的结果，计算右操作数，得到算数异常
    return 0;
}
```

### 位运算符

位运算作用于每一个二进制位并对每一位进行运算

| 运算符 | 描述                                                                   |
| ------ | ---------------------------------------------------------------------- |
| &      | 按位与运算                                                             |
| \|     | 按位或运算                                                             |
| ~      | 按位非运算                                                             |
| ^      | 按位异或运算                                                           |
| <<     | 左移运算符，将所有的二进制为向左移动，超过左侧的二进制位丢弃，右侧补零 |
| >>     | 右移运算符，将所有的二进制为向右移动，超过右侧的二进制位丢弃，左侧补零 |

异或运算真值表如下：

| A   | B   | A ^ B |
| --- | --- | ----- |
| F   | F   | F     |
| F   | T   | T     |
| T   | F   | T     |
| T   | T   | F     |

例如A = 60，B = 13，用二进制表示，可以写成：

```
A      = 0011 1100
B      = 0000 1101
------------------
A & B  = 0000 1100
A | B  = 0011 1101
A ^ B  = 0011 0001
~A     = 1100 0011
!A     = 0000 0000
A && B = 0000 0001
A || B = 0000 0001
A << 2 = 1111 0000
B >> 2 = 0000 0011
```

位运算常用来操作寄存器标志位

例如一个无符号整数占8比特内存，对应8盏小灯。从右向左数，第1~8位分别对应第1~8盏小灯

```C
#include <stdio.h>

int main()
{
    char n;
    scanf("%d", &n);
    char led_reg = 0b01001001;

    // 亮起第3盏灯
    led_reg = led_reg | 0b00000100;

    // 关闭第7盏灯
    led_reg = led_reg & 0b10111111;

    // 开启第n盏灯
    led_reg =  led_reg | 1 << (n-1);

    // 循环左移一位(第1位移到第2位，第2位移到第3位...第8位移到第1位)
    // 效果是向左的流水灯
    led_reg = ((0b10000000 & led_reg) >> 7) | (led_reg << 1);

    // 循环右移一位(第2位移到第1位，第3位移到第2位...第1位移到第8位)
    // 效果是向右的流水灯
    led_reg = ((0b00000001 & led_reg) << 7) | (led_reg >> 1);

    return 0;
}
```

### 赋值运算符

| 运算符 | 描述                         |
| ------ | ---------------------------- |
| =      | 将右操作数赋值到左侧的变量里 |
| +=     | a += b 等同于 a = a + b      |
| -=     | a -= b 等同于 a = a - b      |
| *=     | a *= b 等同于 a = a * b      |
| /=     | a /= b 等同于 a = a / b      |
| %=     | a %= b 等同于 a = a % b      |
| <<=    | a <<= b 等同于 a = a << b    |
| >>=    | a >>= b 等同于 a = a >> b    |
| &=     | a &= b 等同于 a = a & b      |
| \| =   | a \|= b 等同于 a = a \| b    |
| ^=     | a ^= b 等同于 a = a ^ b      |

### 其他运算符

| 运算符   | 描述                     |
| -------- | ------------------------ |
| sizeof() | 返回变量所占内存的字节数 |

sizeof不是函数，而是运算符，运算结果是unsigned long类型

```C
#include <stdio.h>

int main()
{
    int a = 4;
    short b;
    double c;

    printf("变量 a 占%lu字节\n", sizeof(a));
    printf("变量 b 占%lu字节\n", sizeof(b));
    printf("变量 c 占%lu字节\n", sizeof(c));
    printf("float 占%lu字节\n", sizeof(float));
    printf("double 占%lu字节\n", sizeof(double));

    return 0;
}
```

输出：
```
变量 a 占4字节
变量 b 占2字节
变量 c 占8字节
float 占4字节
double 占8字节
```

## 流程控制语句

程序执行的流程可以分为三类：顺序结构、分支结构、循环结构

### 顺序结构

我们之前所写的程序都是顺序结构的，即按照从前到后的顺序执行

### 分支结构

在C语言中，`if...else`语句和`switch...case`语句均可以实现分支结构程序

#### 使用if实现分支结构

if语句的语法如下

```C
if (布尔表达式) {
    许多语句
}
```

只有当小括号里的布尔表达式为真时，才会执行大括号里的许多语句

如果大括号里只有一条语句，可以省略大括号，但不建议你这样做

```C
if (布尔表达式) {
    许多语句A
}
else {
    另外许多语句B
}
```

当布尔表达式为真时，会执行许多语句A，否则会执行许多语句B

我们可以使用`if...else`语句计算除法，当除数为零时输出错误提示

```C
#include <stdio.h>

int main()
{
    double a, b;
    printf("输入两个数，计算它们的商（用空格隔开）:\n");
    scanf("%lf %lf", &a, &b);
    if (b == 0.0)
    {
        printf("除数不能为0\n");
    }
    else
    {
        printf("%f / %f = %f\n", a, b, a / b);
    }
    return 0;
}
```

以上代码确实实现了上述功能，但是不能很好地区分正常执行和异常执行情况，请想象如果有多个异常情况需要判断，那么需要多个嵌套的if语句

一个常用的技巧叫作提前返回

```C
#include <stdio.h>

int main()
{
    double a, b;
    printf("输入两个数，计算它们的商（用空格隔开）:\n");
    scanf("%lf %lf", &a, &b);
    if (b == 0.0)
    {
        printf("除数不能为0\n");
        return 0; // 在main函数里使用return语句会结束程序
    }
    printf("%f / %f = %f\n", a, b, a / b);
    return 0;
}
```

这样可以明显看出if判断的是异常情况，而不缩进的代码处理正常情况，如果有多个异常情况，可以写多个if语句，不会出现嵌套的情况

